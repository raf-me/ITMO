# Лабораторная работа 2

## Написание Docker

Разработка Docker будет проводиться на основе альфа-версии Backend сервиса приложения Smart Receipt. 

Используемый стек сервиса - Java 22, Spring Boot 4.0.0 RC2.0, Maven. 

Ссылка на [репозиторий проекта](https://github.com/raf-me/ITMO/tree/main/FPIn/DemoBackendProject) 

#### Структура Backend:

    src/
    └─ main/
        ├─ java/com/example/demobackendproject
        │  ├─ api/                 # Обёртки над внешними HTTP-API
        │  │   └─ ReceiptDecodeApi.java
        │  ├─ config/              # Java-конфигурация Spring
        │  │   ├─ SecurityConfig.java
        │  │   └─ WebClientConfig.java
        │  ├─ controller/          # REST-контроллеры
        │  │   └─ ReceiptController.java
        │  ├─ dto/                 # DTO для запросов/ответов
        │  │   ├─ CategoryDTO.java
        │  │   ├─ ReceiptItemDTO.java
        │  │   ├─ ReceiptQRRequestDTO.java
        │  │   ├─ ReceiptQrParseDTO.java
        │  │   ├─ ReceiptRequestDTO.java
        │  │   └─ ReceiptResponseDTO.java
        │  └─ service/
        │      └─ HTTP_DATA.java   # Бизнес-логика/оркестрация
        └─ resources/
        ├─ static/index.html    # Пробная страница "сервер работает"
        ├─ application.properties
        └─ test.http            # HTTP-сценарии для теста из IDE

---

## Плохой Dockerfile:

    FROM openjdk:latest
    WORKDIR /app
    COPY . .
    RUN mvn clean package
    EXPOSE 8080
    CMD ["java", "-jar", "target/DemoBackendProject-0.0.1-SNAPSHOT.jar"]

### 1. Использование openjdk:latest

    FROM openjdk:latest

При каждом новом билде Docker может использовать другую версию базового образа, что может привести к:

- неожиданным ошибкам,
- несовместимости библиотек,
- различному поведению контейнера на разных машинах и в разное время.

Кроме того, полный образ Java содержит большое количество компонентов, не необходимых для запуска приложения в production, что увеличивает размер образа и площадь атаки.

### 2. Сборка и запуск приложения в одном образе

    RUN mvn clean package
    CMD ["java", "-jar", "target/DemoBackendProject-0.0.1-SNAPSHOT.jar"]

В одном образе одновременно находятся:

- Maven,
- исходный код,
- build-зависимости,
- временные файлы сборки.

Это приводит к:

- увеличению размера итогового образа,
- более медленной сборке,
- нарушению принципа разделения ответственности.

### 3. Копирование всего контекста сборки

    COPY . .

В контейнер копируется весь проект целиком, включая:
- .git,
- .idea,
- временные файлы,
- тесты и служебные каталоги.

Это:

- увеличивает размер образа,
- ломает Docker cache (пересборка происходит при любом изменении),
- может привести к утечке лишних данных.

### 4. Запуск контейнера от root-пользователя

##### *(В плохом Dockerfile отсутствует инструкция USER, поэтому приложение запускается от root.)*

Если злоумышленник получит доступ внутрь контейнера, он получит root-доступ, что может привести к:

- установке вредоносного ПО,
- чтению и изменению примонтированных volume,
- попыткам выхода из контейнера на хост-систему.

---

## Хороший Dockerfile:

    FROM maven:3.9.9-eclipse-temurin-22 AS build
    WORKDIR /build
    COPY pom.xml .
    RUN mvn dependency:go-offline
    COPY src ./src
    RUN mvn clean package -DskipTests
    
    FROM eclipse-temurin:22-jre
    WORKDIR /app
    RUN addgroup --system spring && adduser --system --ingroup spring spring
    USER spring
    COPY --from=build /build/target/DemoBackendProject-0.0.1-SNAPSHOT.jar app.jar
    EXPOSE 8080
    ENTRYPOINT ["java", "-jar", "/app/app.jar"]


### 1. Использование multi-stage build

    FROM maven:3.9.9-eclipse-temurin-22 AS build

Используется механизм multi-stage build, при котором первая стадия предназначена исключительно для сборки приложения.

Какая плохая практика исправлена:

- Использование одного образа для сборки и запуска
- Попадание Maven, JDK и build-зависимостей в production-образ

Как повлияло исправление:

- Финальный Docker-образ не содержит Maven и JDK
- Значительно уменьшен размер образа
- Снижена поверхность атаки

### 2. Явное задание рабочей директории для сборки

    WORKDIR /build

Явно указывается директория, в которой выполняется сборка проекта.

Какая плохая практика исправлена:

- Выполнение команд в корневом каталоге 
- Неявные пути при копировании файлов

Как повлияло исправление:

- Улучшена читаемость Dockerfile
- Упрощена отладка и сопровождение

### 3. Раздельное копирование pom.xml для кэширования зависимостей

    COPY pom.xml .

Файл pom.xml копируется отдельно от исходного кода.

Какая плохая практика исправлена:

- Копирование всего проекта одной командой COPY . .
- Повторная загрузка зависимостей при каждом изменении кода

Как повлияло исправление:

- Docker эффективно использует кэш
- Сборка образа происходит быстрее

### 4. Предварительная загрузка зависимостей Maven

Зависимости загружаются заранее и кешируются отдельным слоем.

Какая плохая практика исправлена:

- Загрузка зависимостей при каждой сборке
- Сильная зависимость от сети

Как повлияло исправление:

- Ускорение повторных сборок
- Повышение стабильности CI/CD

### 5. Копирование только исходного кода проекта

    COPY src ./src

Копируются только необходимые файлы — исходный код.

Какая плохая практика исправлена:

- Использование ADD . /app
- Попадание лишних файлов (.git, .idea, .env) в образ

Как повлияло исправление:

- Меньше данных в Docker-образе
- Повышена безопасность

### 6. Сборка приложения на стадии build

    RUN mvn clean package -DskipTests

Приложение собирается один раз на этапе build.

Какая плохая практика исправлена:

- Сборка приложения при запуске контейнера
- Запуск тестов в production

Как повлияло исправление:

- Быстрый старт контейнера
- Предсказуемый результат сборки

### 7. Использование минимального runtime-образа

    FROM eclipse-temurin:22-jre

Для запуска используется JRE, а не полный JDK.

Какая плохая практика исправлена:

- Использование полноразмерных образов с компиляторами

Как повлияло исправление:

- Существенно уменьшен размер образа
- Меньше потенциальных уязвимостей

### 8. Выделенная рабочая директория приложения

    WORKDIR /app

Приложение изолировано в собственной директории.

Какая плохая практика исправлена:

- Размещение файлов в корне файловой системы контейнера

Как повлияло исправление:

- Лучшая структура контейнера
- Упрощено сопровождение

### 9. Создание отдельного системного пользователя

    RUN addgroup --system spring && adduser --system --ingroup spring spring

Контейнер не запускается от root.

Какая плохая практика исправлена:

- Запуск контейнера с правами root

Как повлияло исправление:

- Снижен риск эскалации привилегий
- Повышена безопасность контейнера

### 10. Принудительный запуск контейнера от non-root пользователя

    USER spring

Даже при компрометации приложения root-доступ отсутствует.

Как повлияло исправление:

- Контейнер безопаснее в production
- Соответствие security best practices

### 11. Копирование только готового артефакта сборки

    COPY --from=build /build/target/DemoBackendProject-0.0.1-SNAPSHOT.jar app.jar

В финальный образ попадает только .jar файл.

Какая плохая практика исправлена:

- Копирование build-директорий целиком
- Попадание кешей и исходников

Как повлияло исправление:

- Минимальный образ
- Меньшая поверхность атаки

### 12. Порт приложения

    Expose 8080

Явно указывается порт, используемый приложением.

Как повлияло исправление:

- Повышена читаемость Dockerfile
- Упрощена работа с оркестраторами

### 13. Использование exec-формы ENTRYPOINT

    ENTRYPOINT ["java", "-jar", "/app/app.jar"]

Используется exec-форма, а не shell.

Какая плохая практика исправлена:

- Shell ENTRYPOINT, некорректная обработка сигналов

Как повлияло исправление:

- Корректное завершение контейнера
- Правильная обработка SIGTERM и SIGINT


---

## Плохие практики работы с контейнерами

    docker run demo-backend

Контейнер может использовать неограниченное количество CPU и памяти, что может привести к:

- деградации производительности хоста,
- падению других сервисов,
- отказу всей системы при утечке памяти.

Правильный вариант:

      docker run --memory=512m --cpus=1 demo-backend

Результат:

- предсказуемое потребление ресурсов,
- защита хоста от перегрузки,
- более стабильная работа системы.

## Хранение секретов в переменных окружения

    docker run \
      -e RECEIPT_API_TOKEN=real_token_here \
      -p 8080:8080 \
        demo-backend

Переменные окружения:
- легко читаются через docker inspect,
- могут попасть в логи,
- небезопасны при использовании в shared-средах.

Как правильно:

- использовать Docker secrets,
- или внешние системы хранения секретов,
- или .env файлы вне репозитория.

Правильный вариант:

##### Исправленный пример docker run -e:

.env файл:

    RECEIPT_API_TOKEN=token (токен скрыт от git)
    SERVER_PORT=8080
    RECEIPT_API_URL=https://proverkacheka.com/api/v1/check/get
    SPRING_PROFILES_ACTIVE=dev

И запускается:

    docker run --env-file .env demo-backend


---

# Лабораторная работа 2*

## Плохой docker-compose.yml:

    version: "4.0"
    
    services:
      backend:
        image: demo-backend
        container_name: backend_container
        ports:
          - "8080:8080"
        environment:
          RECEIPT_API_TOKEN: token
        networks:
          - shared_network
    
      another_service:
        image: nginx:latest
        container_name: nginx_container
        ports:
          - "80:80"
        networks:
          - shared_network
    
    networks:
      shared_network:
        driver: bridge

### 1. Хранение секретных данных в docker-compose.yml

    environment:
      RECEIPT_API_TOKEN: token

- секрет хранится в открытом виде
- попадает в Git-репозиторий
- легко утекает при копировании файла
- невозможно безопасно менять между окружениями

Риски:

- компрометация API-ключей
- нарушение security best practices

### 2. Использование latest тега образа

    image: nginx:latest

Почему это плохо:

- latest не гарантирует стабильность
- при следующем запуске может скачаться другой образ
- ломается воспроизводимость окружения

Риски:

- неожиданные ошибки
- различия между dev / prod

### 3. Общая сеть для всех сервисов

Почему это плохо:

- все контейнеры видят друг друга
- сервисы могут обращаться напрямую по сети
- отсутствует изоляция

Риски:

- lateral movement при взломе
- нарушение принципа least privilege

## Хороший docker-compose.yml:

    version: "4.0"
    
    services:
      backend:
        image: demo-backend:1.0.0
        container_name: backend_container
        env_file:
          - .env
        ports:
          - "8080:8080"
        networks:
          - backend_net
    
      auxiliary:
        image: nginx:1.27-alpine
        container_name: auxiliary_container
        networks:
          - auxiliary_net
    
    networks:
      backend_net:
        driver: bridge
        internal: true
    
      auxiliary_net:
        driver: bridge
        internal: true

### 1. Использование .env вместо хардкода секретов

    env_file:
      - .env

Здесь секреты вынесены из compose-файла, .env добавляется в .gitignore, разные значения для разных окружений

По итогу:

- повышена безопасность
- упрощена работа с CI/CD
- compose-файл безопасен для GitHub

### 2. Фиксированные версии образов

    image: demo-backend:1.0.0
    image: nginx:1.27-alpine

Здесь изменилось окружение стало воспроизводимым и версия образа известна заранее

И по итогу:
- стабильные сборки
- одинаковое поведение на всех машинах

### 3. Изоляция сервисов по сетям

    networks:
      backend_net:
        internal: true

Здесь изменилось каждый сервис в своей сети и сети помечены как internal

По итогу:

- контейнеры не видят друг друга
- доступ возможен только через проброшенные порты
- соблюдён принцип zero trust networking

## Сетевая изоляция контейнеров

    internal: true

- Для каждого сервиса создана отдельная сеть
- Сервисы не подключены к одной и той же сети

### Принцип изоляции

Принцип изоляции:

- Docker создаёт отдельные bridge-сети
- Контейнер может видеть только контейнеры в той же сети
- internal: true запрещает доступ извне Docker-хоста
- Контейнеры не могут обращаться друг к другу по DNS или IP

По итогу:

- контейнеры поднимаются одновременно
- compose-проект единый
- сетевого взаимодействия между сервисами нет
- безопасность выше, чем в shared-network подходе


### 4. Кэширование

#### когда кэширование в Dockerfile полезно, а когда вредно:

| Сценарий | Почему кэширование хорошо | Почему кэширование плохо |
| -------- | ------------------------- | ------------------------ |
| Сборка зависимостей | Библиотеки редко меняются, можно кэшировать слой "RUN mvn dependency:go-offline" - экономия времени | Если зависимости постоянно обновляются или скачиваются с нестабильного репозитория — кэш даёт «битые» версии |
| Частые правки исходников | Слои с зависимостями не пересобираются - быстрее итерации | Если копировать "." слишком рано - любое изменение файла ломает кэш и пересобирает всё |
| Cборка | Гарантирует одинаковую среду при каждом билде ("immutable infrastructure") | Может "запомнить" старый слой с уязвимостями, если явно не обновлять базовый образ |
| CI/CD | Уменьшает нагрузку на билд-сервер - быстрее тесты и деплой | При неосторожной настройке можно получить невалидный кеш - баги, которые не воспроизводятся локально |
